#!/bin/bash
# 
# This script is written to be used mainly in GitLab CI Pipeline, it is used to
# checkout a verified git commit to be later used in deploy stage. This script
# is meant to verify git commits coming from external VCS provider such as
# GitHub, bitbucket etc. At present, it can only checkout and verify commits
# from only those SUSE employees whose public GPG keys are uploaded in GitLab
# and can be fetched using GET request on GitLab user API endpoint
# https://gitlab.suse.de/api/v4/users/$uid/gpg_keys

# Usage:
# $0 /path/to/checkout https://untrusted.forge/path/to/repo.git

url="$2" # only required on first call - ignored on later calls

set -euo pipefail

target=$1

mkdir -p "$target"
cd "$target"
if [[ ! -d ".git" ]]; then
    if [[ -z "$url" ]]; then
        echo "No previous git checkout at ${target} and no URL provided" >&2
        exit 1
    fi
    echo "Initializing repo"
    git init -b master
    git config gpg.ssh.allowedSignersFile /dev/null
    git remote add --no-tags origin "$url"
else
    rurl=$(git remote get-url origin)
    if [[ "$rurl" != "$url" ]] ; then
        echo "Repo already present with different remote url: $rurl" >&2
        exit 1
    fi
fi

fetch_depth=2
sha=
default_remote_branch=
tmpdir=$(mktemp -d /tmp/tmp.git-sha-verify-XXXXXX)
trap '[[ -z "$tmpdir" ]] || rm -rf "$tmpdir"' EXIT

while [[ -z $sha ]];
do
    echo "Fetching with depth $fetch_depth"
    fetch_result=$(git fetch --progress --depth=$fetch_depth 2>&1)
    regex='remote:.*Total 0 .*'
    if [[ $fetch_result =~ $regex ]]; then
        if [[ $fetch_depth == 2 ]]; then
            echo "Nothing new on the server"
            exit 0
        else
            break
        fi
    fi

    if [[ -z "$default_remote_branch" ]]; then
	    git remote set-head origin --auto
	    default_remote_branch=$(git symbolic-ref refs/remotes/origin/HEAD --short) # e.g. origin/master
    fi
    names=$(git log --committer="suse" --pretty="%cl" "$default_remote_branch" | sort -u)

    if [ -n "$names" ]; then
        for n in $names; do
            [[ -e "$tmpdir/${n}.pub" ]] && continue
            echo "Receiving key for $n"
            uid=$(curl -s --fail-with-body --request GET "https://gitlab.suse.de/api/v4/users?username=$n" | jq -r '.[].id?')
            if [[ -n "${uid}" ]]; then
                curl -s --fail-with-body --request GET "https://gitlab.suse.de/api/v4/users/$uid/gpg_keys" | jq -r '.[].key?' >>"${tmpdir}/${n}.pub"
            fi
            if [[ -e "$tmpdir/${n}.pub" ]]; then
                (gpg --show-keys "$tmpdir/${n}.pub" && gpg -q --import "$tmpdir/${n}.pub") ||:
            fi
        done
    fi
    # "G" = good (valid) signature
    # "B" = bad signature
    # "U" = good signature with unknown validity
    # "X" = good signature that has expired
    # "Y" = good signature made by an expired key
    # "R" = good signature made by a revoked key
    # "E" = signature cannot be checked (e.g. missing key)
    # "N" = no signature
    sha=$(git log --pretty="%G? %H" "$default_remote_branch" | grep -m 1 -oP '(?<=[UG] ).*') ||:
    fetch_depth=$((fetch_depth * 2))
done

if [ -z "$sha" ]; then
    echo "Couldn't find a signed commit" >&2
    exit 1
fi
git switch -q --detach "$sha"
echo "HEAD is now at $(git rev-parse HEAD)"
